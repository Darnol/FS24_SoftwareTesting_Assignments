1. There is one external dependency, which is `HttpUtil`. I will mock this dependency, because it communicated with an external API, which can make the tests slow or flaky (If the external API isn't available for some reason)

2. To replace the dependency easily with a mock in testing, I have to use dependency injection. I will pass an `HttpUtil` object to the `CatFactsRetriever` in the constructor. (Not as a method parameter, because all methods in `CatFactsRetriever` use it). I also made the `get` method non-static, to make it easily mockable with mockito. By doing that I can pass in a Mock for my tests. Controlability and Observability are sufficient already.

3. If there was a change in the `HttpUtil`, for example it would return the entity directly without calling `toString` on it, the tests would not fail, since the mocks still return a string. So if the `HttpUtil` was changed, the changes and violations of contracts would have to be carefully considered, also in the test suite. Another problem is is the increased coupling of the method with the tests. Because the `HttpUtil` is mocked, I need to know that the `get` method of the `HttpUtil` is called and consider this in my tests, so if the implementation of `HttpUtil` changed, my tests might have to change aswell, even if the contract stayed the same. Another disadvantage, I realized when writing test for when the limit parameter for `retrieveLongest` is 0. I wrote the test configuring the mock to return an empty list in that case but then went to check the API and realized it actually returns a ling list of facts in that case. So the contract of the external dependencies have to be looked at closely and replicated accurately by the mock. In this case I added a precondition, that returns an empty string immediately, when the limit parameter is < 0.